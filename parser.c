// Parser
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* Global declarations */
/* Variables */
int charClass;
char lexeme [100];
char nextChar;
int lexLen;
int token;
int nextToken;
FILE *in_fp, *fopen();

char *line_exp = NULL;
int row_num = 0;
int col_num = 1;
int char_index;
int end_index;
char end_index;

/* Function declarations */
void addChar();
void getChar();
void getNonBlank();
int lex();
void factor();
void term();
void expr();
void error();

/* Character classes */
#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99

/* Token codes */
#define INT_LIT 10
#define IDENT 11
#define ASSIGN_OP 20
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26


/* Return value -1 if the error occurred.
*/
int factor() {
  printf("Enter <factor>\n", );

  if (nextToken == IDENT || nextToken == INT_LIT) {
    // Get the next token
    lex();
  } else {
    if (nextToken == LEFT_PAREN) {
      lex();
      expr();
      if (nextToken == RIGHT_PAREN) {
        lex();
      } else {
        error();
        return -1;
      }
    } else {
      error();
      return -1;
    }
  }
  printf("Exit <factor>\n", );
  return 0;
} /* End of fucntion factor */

/* term
   Parses strings in the language generated by the rule:
   <term> -> <factor> {(* | /) <factor>)
*/
int term() {
  printf("Enter <term>\n");

  /* Parse the first factor */

  if (factor() == -1) {
    return -1;
  }

  /* As long as the next token is * or /, get the
    next token and parse the next factor
   */
  while nextToken == MULTI_OP || nextToken == DIV_OP) {
    lex();
    if (factor() == -1) {
      return -1;
    }
  }
  printf("Exit <term>\n", );
  return 0;
} /* End of function term */

/* expr
  Parses strings in the language generated by the rule:
  <expr> -> <term> {(+ | -) <term>}
*/

int expr() {
  printf("Enter <expr>\n");

  /* Parse the first term */
  if (term() == -1) {
    return -1;
  }

  /* As long as the next token is + or -, get
    the next token and parse the next term */
  while (nextToken == ADD_OP || nextToken == SUB_OP) {
     lex();
     if (term() == -1) {
       return -1;
     }
  }
  printf("Exit <expr>\n");
  return 0;

} /* End of function expr */

/* lookup - a function to lookup operators and parentheses
  and return the token
*/
int lookup(char ch) {
  switch (ch) {
    case '(':
      addChar();
      nextToken = LEFT_PAREN;
      break;
    case ')':
      addChar();
      nextToken = RIGHT_PAREN;
      break;
    case '+':
      addChar();
      nextToken = ADD_OP;
      break;
    case '-':
      addChar();
      nextToken = SUB_OP;
      break;
    case '*':
      addChar();
      nextToken = MULT_OP;
      break;
    case '/':
      addChar();
      nextToken = DIV_OP;
      break;
    default:
      addChar();
      nextToken = EOF;
      break;
    }
    return nextToken;
}

/* addChar - a function to add nextChar to lexeme
*/
void addChar() {
  if (lexLen <= 98) {
    lexeme[lexLen++] = nextChar;
    lexeme[lexLen] = 0;
  } else
    printf("Error - lexeme is too long \n");
}

/* getChar - a function to get the next character of
  input and determine its character class
*/
void getChar() {
  if (line_exp[char_index] != '\n' && line_exp[char_index] != '\0') {
    col_num++;
    nextChar = line_exp[char_index++];
    if (isalpha(nextChar))
      charClass = LETTER;
    else if (isdigit(nextChar))
      charClass = DIGIT;
    else charClass = UNKNOWN;
  } else
     charClass = EOF;
}

/* getNonBlank - a function to call getChar until it
  returns a non-whitespace character
*/
void getNonBlank() {
  while (isspace(nextChar))
    getChar();
}

/* lex - a simple lexical analyzer for arithmetic
  expressions
*/
int lex() {
  lexLen = 0;
  getNonBlank();
  end_char = nextChar;
  end_index = col_num;

  switch (charClass) {
    /* Parse identifiers */
    case LETTER:
      addChar();
      getChar();
      while (charClass == LETTER || charClass == DIGIT) {
        addChar();
        getChar();
      }
      nextToken = IDENT;
      break;

    /* Parse integer literals */
    case DIGIT:
      addChar();
      getChar();
      while (charClass == DIGIT) {
        addChar();
        getChar();
      }
      nextToken = INT_LIT;
      break;

    /* Parentheses and operators */
    case UNKNOWN:
      lookup(nextChar);
      getChar();
      break;

    /* EOF */
    case EOF:
      nextToken = EOF;
      lexeme[0] = 'E';
      lexeme[1] = 'O';
      lexeme[2] = 'F';
      lexeme[3] = 0;
      break;
    } /* End of switch */
    printf("Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);
    return nextToken;
} /* End of function lex */

/* Prints where the error occurred while parsing.
*/
void error() {
  printf("Syntax error in line %d at column %d\n", row_num, col_num);
  char *read;
  read = (char*) malloc(char_index);
  memset(read, '\0', sizeof(read));
  strncpy(read, line_exp, end_index-1);
  printf("Error at character %c while parsing.\n", read, end_char);
  free(read);
  // exit(0);
}

/* Driver function
*/
void main(int argc, char *argv[]) {
  size_t len = 0;
  ssize_t read;

  /* Correct execution should have argc value = 2
  */
  if (argc != 2) {
    printf("Error in parsing or reading the filename.\n");
    exit(0);
  } else {
      /* Open the input data file and process its contents */
      if ((in_fp = fopen(argv[1], "r")) == NULL) {
        printf("ERROR - cannot open %s \n", argv[1]);
      } else {
        while ((read = getline(&line_exp, &len, in_fp)) != -1) {
          row_num++;
          char_index = 0;
          col_num = 1;
          getChar();

          if (line_exp != NULL) {
            do {
              lex();
              if (expr() == -1) {
                break;
              }
            } while (nextToken != EOF);
          } else {
            printf("Empty expression\n");
          }
          printf("\n");
        }
      }
    }
    /* End of main */
}
